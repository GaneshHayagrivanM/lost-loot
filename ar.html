<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lost Loot - AR View</title>
    <link rel="stylesheet" href="css/styles.css">
    <!-- A-Frame and AR.js -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.min.js"></script>
</head>
<body class="ar-page">
    <!-- AR Scene -->
    <a-scene
        embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
        renderer="logarithmicDepthBuffer: true;"
        vr-mode-ui="enabled: false"
        gesture-detector
        id="ar-scene"
        loading-screen="enabled: false"
    >
        <!-- Assets -->
        <a-assets>
            <!-- Placeholder for 3D models -->
            <a-asset-item id="compass-model" src="assets/models/compass.gltf"></a-asset-item>
            <a-asset-item id="ship-model" src="assets/models/ship.gltf"></a-asset-item>
            <a-asset-item id="chest-model" src="assets/models/chest.gltf"></a-asset-item>
            <a-asset-item id="skeleton-model" src="assets/models/skeleton.gltf"></a-asset-item>
            <a-asset-item id="key-model" src="assets/models/key.gltf"></a-asset-item>
            
            <!-- Marker patterns -->
            <!-- Note: a-marker-camera is not needed when using pattern markers -->
        </a-assets>
        
        <!-- Checkpoint 1: Captain's Compass -->
        <a-marker
            id="marker-1"
            type="pattern"
            url="assets/markers/marker-1.patt"
            markerhandler
            checkpoint="1"
            raycaster="objects: .interactive"
            cursor="fuse: false; rayOrigin: mouse"
        >
            <a-entity id="checkpoint-1-content" visible="false">
                <!-- Compass minigame -->
                <a-box
                    id="compass-box"
                    position="0 0.5 0"
                    rotation="0 45 0"
                    color="#8B4513"
                    scale="0.5 0.5 0.5"
                    class="interactive"
                    animation="property: rotation; to: 0 405 0; loop: true; dur: 4000"
                >
                    <a-text
                        value="Captain's Compass"
                        position="0 1 0"
                        align="center"
                        color="#FFD700"
                        scale="2 2 2"
                    ></a-text>
                </a-box>
                
                <!-- Compass needle -->
                <a-cylinder
                    id="compass-needle"
                    radius="0.02"
                    height="0.4"
                    color="#FF0000"
                    position="0 0.7 0"
                    rotation="0 0 0"
                ></a-cylinder>
                
                <!-- Instructions -->
                <a-text
                    value="Point your device north to activate the compass!"
                    position="0 -0.5 0"
                    align="center"
                    color="#FFFFFF"
                    scale="1.5 1.5 1.5"
                ></a-text>
            </a-entity>
        </a-marker>
        
        <!-- Fallback marker-1 using preset -->
        <a-marker
            id="marker-1-fallback"
            preset="hiro"
            markerhandler
            checkpoint="1"
            visible="false"
            raycaster="objects: .interactive"
            cursor="fuse: false; rayOrigin: mouse"
        >
            <a-entity id="checkpoint-1-fallback-content" visible="false">
                <!-- Same content as primary marker -->
                <a-box
                    position="0 0.5 0"
                    rotation="0 45 0"
                    color="#8B4513"
                    scale="0.5 0.5 0.5"
                    class="interactive"
                    animation="property: rotation; to: 0 405 0; loop: true; dur: 4000"
                >
                    <a-text
                        value="Captain's Compass (Hiro)"
                        position="0 1 0"
                        align="center"
                        color="#FFD700"
                        scale="2 2 2"
                    ></a-text>
                </a-box>
                
                <!-- Compass needle -->
                <a-cylinder
                    radius="0.02"
                    height="0.4"
                    color="#FF0000"
                    position="0 0.7 0"
                    rotation="0 0 0"
                ></a-cylinder>
                
                <!-- Instructions -->
                <a-text
                    value="Point your device north to activate the compass!"
                    position="0 -0.5 0"
                    align="center"
                    color="#FFFFFF"
                    scale="1.5 1.5 1.5"
                ></a-text>
            </a-entity>
        </a-marker>
        
        <!-- Checkpoint 2: Kraken's Quiz -->
        <a-marker
            id="marker-2"
            type="pattern"
            url="assets/markers/marker-2.patt"
            markerhandler
            checkpoint="2"
        >
            <a-entity id="checkpoint-2-content" visible="false">
                <!-- Kraken representation -->
                <a-sphere
                    id="kraken-head"
                    radius="0.3"
                    color="#4B0082"
                    position="0 0.5 0"
                    class="interactive"
                >
                    <a-text
                        value="Kraken's Quiz"
                        position="0 1 0"
                        align="center"
                        color="#FFD700"
                        scale="2 2 2"
                    ></a-text>
                </a-sphere>
                
                <!-- Tentacles -->
                <a-cylinder radius="0.05" height="0.8" color="#4B0082" position="0.2 0 0.2" rotation="15 0 0"></a-cylinder>
                <a-cylinder radius="0.05" height="0.8" color="#4B0082" position="-0.2 0 0.2" rotation="-15 0 0"></a-cylinder>
                <a-cylinder radius="0.05" height="0.8" color="#4B0082" position="0.2 0 -0.2" rotation="15 0 0"></a-cylinder>
                <a-cylinder radius="0.05" height="0.8" color="#4B0082" position="-0.2 0 -0.2" rotation="-15 0 0"></a-cylinder>
                
                <!-- Quiz question display -->
                <a-text
                    id="quiz-question"
                    value="What flag do pirates fly?\nA) Jolly Roger  B) Union Jack  C) Tricolor"
                    position="0 -0.5 0"
                    align="center"
                    color="#FFFFFF"
                    scale="1.2 1.2 1.2"
                ></a-text>
            </a-entity>
        </a-marker>
        
        <!-- Checkpoint 3: Cannonball Accuracy -->
        <a-marker
            id="marker-3"
            type="pattern" 
            url="assets/markers/marker-3.patt"
            markerhandler
            checkpoint="3"
        >
            <a-entity id="checkpoint-3-content" visible="false">
                <!-- Cannon -->
                <a-cylinder
                    id="cannon"
                    radius="0.1"
                    height="0.6"
                    color="#2F4F4F"
                    rotation="0 0 90"
                    position="0 0.3 0"
                    class="interactive"
                ></a-cylinder>
                
                <!-- Target -->
                <a-ring
                    id="target"
                    radius-inner="0.1"
                    radius-outer="0.2"
                    color="#FF0000"
                    position="0 0.5 -1"
                    class="interactive"
                ></a-ring>
                
                <a-text
                    value="Cannonball Accuracy\nTap to fire!"
                    position="0 1 0"
                    align="center"
                    color="#FFD700"
                    scale="1.5 1.5 1.5"
                ></a-text>
            </a-entity>
        </a-marker>
        
        
        <!-- Additional markers for checkpoints 4-8 -->
        <!-- Checkpoint 4: Treasure Chest Lock -->
        <a-marker id="marker-4" type="pattern" url="assets/markers/marker-4.patt" markerhandler checkpoint="4">
            <a-entity id="checkpoint-4-content" visible="false">
                <a-box position="0 0.5 0" color="#8B4513" scale="0.6 0.4 0.4">
                    <a-text value="Treasure Chest Lock" position="0 1 0" align="center" color="#FFD700" scale="1.5 1.5 1.5"></a-text>
                </a-box>
            </a-entity>
        </a-marker>
        
        <!-- Checkpoint 5: Pirate's Balance -->
        <a-marker id="marker-5" type="pattern" url="assets/markers/marker-5.patt" markerhandler checkpoint="5">
            <a-entity id="checkpoint-5-content" visible="false">
                <a-cylinder radius="0.3" height="0.1" color="#8B4513" position="0 0.5 0">
                    <a-text value="Pirate's Balance" position="0 1 0" align="center" color="#FFD700" scale="1.5 1.5 1.5"></a-text>
                </a-cylinder>
            </a-entity>
        </a-marker>
        
        <!-- Checkpoint 6: Skeleton Duel -->
        <a-marker id="marker-6" type="pattern" url="assets/markers/marker-6.patt" markerhandler checkpoint="6">
            <a-entity id="checkpoint-6-content" visible="false">
                <a-sphere radius="0.2" color="#F5F5DC" position="0 0.7 0">
                    <a-text value="Skeleton Duel" position="0 1 0" align="center" color="#FFD700" scale="1.5 1.5 1.5"></a-text>
                </a-sphere>
                <a-cylinder radius="0.1" height="0.6" color="#F5F5DC" position="0 0.3 0"></a-cylinder>
            </a-entity>
        </a-marker>
        
        <!-- Checkpoint 7: Map Assembly -->
        <a-marker id="marker-7" type="pattern" url="assets/markers/marker-7.patt" markerhandler checkpoint="7">
            <a-entity id="checkpoint-7-content" visible="false">
                <a-plane width="0.8" height="0.6" color="#DEB887" position="0 0.5 0" rotation="-90 0 0">
                    <a-text value="Map Assembly" position="0 0 1" align="center" color="#8B4513" scale="2 2 2"></a-text>
                </a-plane>
            </a-entity>
        </a-marker>
        
        <!-- Checkpoint 8: The Lost Loot -->
        <a-marker id="marker-8" type="pattern" url="assets/markers/marker-8.patt" markerhandler checkpoint="8">
            <a-entity id="checkpoint-8-content" visible="false">
                <a-box position="0 0.5 0" color="#FFD700" scale="0.5 0.3 0.5">
                    <a-text value="The Lost Loot" position="0 1 0" align="center" color="#8B4513" scale="1.5 1.5 1.5"></a-text>
                </a-box>
                <a-sphere radius="0.1" color="#FFD700" position="0.2 0.8 0.2"></a-sphere>
                <a-sphere radius="0.1" color="#FFD700" position="-0.2 0.8 0.2"></a-sphere>
                <a-sphere radius="0.1" color="#FFD700" position="0 0.8 -0.2"></a-sphere>
            </a-entity>
        </a-marker>
        
        <!-- Fallback preset markers for better detection reliability -->
        <a-marker id="marker-2-fallback" preset="kanji" markerhandler checkpoint="2" visible="false">
            <a-entity id="checkpoint-2-fallback-content" visible="false">
                <a-sphere radius="0.3" color="#4B0082" position="0 0.5 0" class="interactive">
                    <a-text value="Kraken's Quiz (Kanji)" position="0 1 0" align="center" color="#FFD700" scale="2 2 2"></a-text>
                </a-sphere>
            </a-entity>
        </a-marker>
        
        <!-- Additional fallback markers using different presets -->
        <a-marker id="marker-3-fallback" preset="hiro" markerhandler checkpoint="3" visible="false">
            <a-entity id="checkpoint-3-fallback-content" visible="false">
                <a-cylinder radius="0.1" height="0.6" color="#2F4F4F" rotation="0 0 90" position="0 0.3 0" class="interactive"></a-cylinder>
                <a-text value="Cannonball Accuracy (Hiro)" position="0 1 0" align="center" color="#FFD700" scale="1.5 1.5 1.5"></a-text>
            </a-entity>
        </a-marker>
        
        <!-- Additional markers for other checkpoints would be defined similarly -->
        <!-- For brevity, I'll implement the remaining markers in the JavaScript -->
        
        <!-- Camera -->
        <a-entity camera look-controls wasd-controls-enabled="false"></a-entity>
    </a-scene>
    
    <!-- AR UI Overlay -->
    <div class="ar-ui-overlay">
        <header class="ar-header">
            <button id="back-to-hud" class="back-btn">← Back to HUD</button>
            <h2 id="ar-title">Scan a Marker</h2>
        </header>
        
        <div id="ar-instructions" class="ar-instructions">
            <p>Point your camera at an AR marker to begin the minigame</p>
        </div>
        
        <!-- Minigame UI -->
        <div id="minigame-ui" class="minigame-ui" style="display: none;">
            <div id="minigame-content"></div>
            <div class="minigame-controls">
                <button id="minigame-action" class="action-btn">Action</button>
                <button id="minigame-reset" class="reset-btn">Reset</button>
            </div>
        </div>
        
        <!-- Progress indicator -->
        <div id="checkpoint-indicator" class="checkpoint-indicator">
            <span id="current-checkpoint">Checkpoint: None</span>
            <div id="progress-bar" class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="js/utils.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/game-state.js"></script>
    <script src="js/ar-minigames.js"></script>
    
    <script>
        let currentCheckpoint = null;
        let currentMinigame = null;
        let deviceOrientationHandler = null;
        let arSceneReady = false;
        let arInitialized = false;
        
        // Initialize AR view with proper error handling
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing AR view...');
            
            try {
                // Check if team is logged in
                if (!GameState.isInitialized()) {
                    window.location.href = 'index.html';
                    return;
                }
                
                // Check AR.js compatibility first - with retry logic
                let compatibilityCheck;
                let retryCount = 0;
                const maxRetries = 3;
                
                do {
                    compatibilityCheck = await ARUtils.checkARjsCompatibility();
                    if (!compatibilityCheck.compatible && retryCount < maxRetries) {
                        console.log(`AR.js compatibility check failed (attempt ${retryCount + 1}/${maxRetries + 1}), retrying...`);
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                        retryCount++;
                    }
                } while (!compatibilityCheck.compatible && retryCount <= maxRetries);
                
                if (!compatibilityCheck.compatible) {
                    console.error('AR.js compatibility issue:', compatibilityCheck.reason);
                    showError(`AR compatibility issue: ${compatibilityCheck.reason}. Please refresh the page and ensure A-Frame and AR.js are loaded.`);
                    return;
                }
                
                // Check AR support before proceeding
                if (!await checkARSupport()) {
                    showError('AR is not supported on this device. Please use a device with camera support.');
                    return;
                }
                
                // Validate marker files
                await validateMarkerFiles();
                
                // Request camera permission early
                const cameraPermission = await requestCameraPermission();
                if (!cameraPermission) {
                    showError('Camera permission is required for AR functionality. Please allow camera access and refresh the page.');
                    return;
                }
                
                setupEventListeners();
                
                // Wait for A-Frame scene to be ready before registering components
                const scene = document.querySelector('#ar-scene');
                if (scene.hasLoaded) {
                    console.log('A-Frame scene already loaded');
                    onSceneReady();
                } else {
                    console.log('Waiting for A-Frame scene to load...');
                    scene.addEventListener('loaded', onSceneReady);
                    
                    // Add timeout for scene loading
                    setTimeout(() => {
                        if (!arSceneReady) {
                            console.error('Scene loading timeout');
                            showError('AR scene failed to load. Please refresh the page.');
                        }
                    }, 10000); // 10 second timeout
                }
                
                requestDeviceOrientation();
                
            } catch (error) {
                console.error('Error initializing AR view:', error);
                showError('Failed to initialize AR view. Please refresh the page and try again.');
            }
        });
        
        async function validateMarkerFiles() {
            console.log('Validating marker files...');
            const markerUrls = [
                'assets/markers/marker-1.patt',
                'assets/markers/marker-2.patt',
                'assets/markers/marker-3.patt',
                'assets/markers/marker-4.patt',
                'assets/markers/marker-5.patt',
                'assets/markers/marker-6.patt',
                'assets/markers/marker-7.patt',
                'assets/markers/marker-8.patt'
            ];
            
            const validationResults = await Promise.all(
                markerUrls.map(url => ARUtils.validateMarkerFile(url))
            );
            
            const failedMarkers = markerUrls.filter((url, index) => !validationResults[index]);
            
            if (failedMarkers.length > 0) {
                console.warn('Some marker files failed validation:', failedMarkers);
                showMessage(`Some marker patterns may not work properly. Fallback markers available.`);
            } else {
                console.log('All marker files validated successfully');
            }
        }
        
        async function checkARSupport() {
            try {
                // Use existing ARUtils function
                const supported = ARUtils.isARSupported();
                console.log('AR support check result:', supported);
                return supported;
            } catch (error) {
                console.error('AR support check failed:', error);
                return false;
            }
        }
        
        async function requestCameraPermission() {
            try {
                console.log('Requesting camera permission...');
                // Use existing ARUtils function
                const granted = await ARUtils.requestCameraPermission();
                console.log('Camera permission result:', granted);
                return granted;
            } catch (error) {
                console.error('Camera permission error:', error);
                return false;
            }
        }
        
        function onSceneReady() {
            console.log('A-Frame scene is ready, initializing AR components...');
            arSceneReady = true;
            
            try {
                initializeMarkerHandlers();
                initializeARErrorHandling();
                arInitialized = true;
                console.log('AR initialization completed successfully');
                showMessage('AR initialized. Point your camera at a marker to begin!');
            } catch (error) {
                console.error('Error during AR initialization:', error);
                showError('Failed to initialize AR components. Please refresh the page.');
            }
        }
        
        function initializeARErrorHandling() {
            const scene = document.querySelector('#ar-scene');
            
            // Handle AR.js errors with specific error types
            scene.addEventListener('arError', (event) => {
                console.error('AR Error:', event.detail);
                const errorType = event.detail?.type || 'unknown';
                let errorMessage = 'AR tracking error. Please ensure good lighting and try again.';
                
                switch (errorType) {
                    case 'camera':
                        errorMessage = 'Camera error. Please check camera permissions and refresh the page.';
                        break;
                    case 'marker':
                        errorMessage = 'Marker detection error. Please ensure the marker is visible and well-lit.';
                        break;
                    case 'webgl':
                        errorMessage = 'WebGL error. Please try refreshing the page or use a different browser.';
                        break;
                    default:
                        errorMessage = `AR error (${errorType}). Please ensure good lighting and try again.`;
                }
                
                showError(errorMessage);
            });
            
            // Handle camera errors specifically
            scene.addEventListener('camera-error', (event) => {
                console.error('Camera Error:', event.detail);
                const errorDetail = event.detail?.message || 'Unknown camera error';
                showError(`Camera error: ${errorDetail}. Please check camera permissions and try again.`);
            });
            
            // Handle WebGL context lost
            scene.addEventListener('webglcontextlost', (event) => {
                console.error('WebGL context lost');
                event.preventDefault();
                showError('Graphics context lost. Please refresh the page.');
            });
            
            // Handle WebGL context restored
            scene.addEventListener('webglcontextrestored', (event) => {
                console.log('WebGL context restored');
                showMessage('Graphics context restored. AR should work normally now.');
            });
            
            // Add global error handler for uncaught AR.js errors
            window.addEventListener('error', (event) => {
                if (event.message && event.message.includes('AR')) {
                    console.error('Uncaught AR error:', event);
                    showError('Unexpected AR error occurred. Please refresh the page.');
                }
            });
            
            // Add unhandled promise rejection handler
            window.addEventListener('unhandledrejection', (event) => {
                if (event.reason && typeof event.reason === 'object' && 
                    (event.reason.message?.includes('AR') || event.reason.message?.includes('camera'))) {
                    console.error('Unhandled AR promise rejection:', event);
                    showError('AR initialization failed. Please refresh the page and allow camera access.');
                }
            });
        }
        
        function setupEventListeners() {
            document.getElementById('back-to-hud').addEventListener('click', () => {
                window.location.href = 'hud.html';
            });
            
            document.getElementById('minigame-action').addEventListener('click', handleMinigameAction);
            document.getElementById('minigame-reset').addEventListener('click', resetCurrentMinigame);
        }
        
        function initializeMarkerHandlers() {
            console.log('Registering marker handler component...');
            
            // Register enhanced marker found/lost handlers with fallback support
            AFRAME.registerComponent('markerhandler', {
                schema: {
                    checkpoint: {type: 'number'}
                },
                
                init: function() {
                    console.log(`Initializing marker handler for checkpoint ${this.data.checkpoint}`);
                    const markerId = this.el.id;
                    const isFallback = markerId.includes('fallback');
                    
                    this.el.addEventListener('markerFound', () => {
                        const checkpoint = this.data.checkpoint;
                        console.log(`✅ Marker ${checkpoint} found - ${markerId} (${isFallback ? 'fallback' : 'primary'})`);
                        
                        // Hide fallback markers when primary is found and vice versa
                        if (!isFallback) {
                            hideFallbackMarker(checkpoint);
                        } else {
                            hidePrimaryMarker(checkpoint);
                        }
                        
                        activateCheckpoint(checkpoint, isFallback);
                    });
                    
                    this.el.addEventListener('markerLost', () => {
                        const checkpoint = this.data.checkpoint;
                        console.log(`❌ Marker ${checkpoint} lost - ${markerId} (${isFallback ? 'fallback' : 'primary'})`);
                        
                        // Small delay before deactivating to avoid flickering
                        setTimeout(() => {
                            if (!isAnyMarkerVisible(checkpoint)) {
                                deactivateCheckpoint();
                            }
                        }, 500);
                    });
                    
                    // Add error handling for marker events
                    this.el.addEventListener('markerError', (event) => {
                        console.error(`Marker error for ${markerId}:`, event.detail);
                        showError(`Marker detection error. Please ensure good lighting and try again.`);
                    });
                }
            });
            
            console.log('Marker handler component registered successfully');
        }
        
        function hideFallbackMarker(checkpoint) {
            const fallbackMarker = document.querySelector(`#marker-${checkpoint}-fallback`);
            if (fallbackMarker) {
                fallbackMarker.setAttribute('visible', 'false');
            }
        }
        
        function hidePrimaryMarker(checkpoint) {
            const primaryMarker = document.querySelector(`#marker-${checkpoint}`);
            if (primaryMarker) {
                primaryMarker.setAttribute('visible', 'false');
            }
        }
        
        function isAnyMarkerVisible(checkpoint) {
            const primaryMarker = document.querySelector(`#marker-${checkpoint}`);
            const fallbackMarker = document.querySelector(`#marker-${checkpoint}-fallback`);
            
            return (primaryMarker && primaryMarker.object3D.visible) || 
                   (fallbackMarker && fallbackMarker.object3D.visible);
        }
        
        function activateCheckpoint(checkpointNumber, isFallback = false) {
            console.log(`Activating checkpoint ${checkpointNumber}... (${isFallback ? 'fallback' : 'primary'} marker)`);
            
            const state = GameState.getState();
            
            // Check if checkpoint is unlocked
            if (checkpointNumber > 1 && !state.checkpoints.includes(checkpointNumber - 1)) {
                const message = `Checkpoint ${checkpointNumber} is locked! Complete previous checkpoints first.`;
                console.warn(message);
                showMessage(message);
                return;
            }
            
            // Check if already completed
            if (state.checkpoints.includes(checkpointNumber)) {
                const message = `Checkpoint ${checkpointNumber} already completed!`;
                console.log(message);
                showMessage(message);
                return;
            }
            
            currentCheckpoint = checkpointNumber;
            
            // Show appropriate checkpoint content (primary or fallback)
            const contentId = isFallback ? 
                `#checkpoint-${checkpointNumber}-fallback-content` : 
                `#checkpoint-${checkpointNumber}-content`;
            
            const content = document.querySelector(contentId);
            if (content) {
                content.setAttribute('visible', 'true');
                console.log(`Checkpoint ${checkpointNumber} content made visible (${isFallback ? 'fallback' : 'primary'})`);
            } else {
                console.warn(`Checkpoint ${checkpointNumber} content element not found: ${contentId}`);
                
                // Try fallback content if primary not found
                if (!isFallback) {
                    const fallbackContent = document.querySelector(`#checkpoint-${checkpointNumber}-fallback-content`);
                    if (fallbackContent) {
                        fallbackContent.setAttribute('visible', 'true');
                        console.log(`Using fallback content for checkpoint ${checkpointNumber}`);
                    }
                }
            }
            
            // Update UI
            const markerType = isFallback ? ' (Fallback)' : '';
            document.getElementById('ar-title').textContent = getCheckpointName(checkpointNumber) + markerType;
            document.getElementById('current-checkpoint').textContent = `Checkpoint: ${checkpointNumber}${markerType}`;
            
            // Initialize minigame
            try {
                initializeMinigame(checkpointNumber);
                console.log(`Checkpoint ${checkpointNumber} activated successfully`);
                showMessage(`Checkpoint ${checkpointNumber} activated! ${isFallback ? 'Using fallback marker.' : ''}`);
            } catch (error) {
                console.error(`Error initializing minigame for checkpoint ${checkpointNumber}:`, error);
                showError('Error starting minigame. Please try scanning the marker again.');
            }
        }
        
        function deactivateCheckpoint() {
            if (currentCheckpoint) {
                console.log(`Deactivating checkpoint ${currentCheckpoint}...`);
                
                // Hide both primary and fallback content
                const primaryContent = document.querySelector(`#checkpoint-${currentCheckpoint}-content`);
                const fallbackContent = document.querySelector(`#checkpoint-${currentCheckpoint}-fallback-content`);
                
                if (primaryContent) {
                    primaryContent.setAttribute('visible', 'false');
                }
                if (fallbackContent) {
                    fallbackContent.setAttribute('visible', 'false');
                }
                
                // Re-enable both primary and fallback markers for future detection
                const primaryMarker = document.querySelector(`#marker-${currentCheckpoint}`);
                const fallbackMarker = document.querySelector(`#marker-${currentCheckpoint}-fallback`);
                
                if (primaryMarker) {
                    primaryMarker.setAttribute('visible', 'true');
                }
                if (fallbackMarker) {
                    fallbackMarker.setAttribute('visible', 'true');
                }
                
                // Reset UI
                document.getElementById('ar-title').textContent = 'Scan a Marker';
                document.getElementById('current-checkpoint').textContent = 'Checkpoint: None';
                document.getElementById('minigame-ui').style.display = 'none';
                
                // Cleanup minigame
                if (currentMinigame) {
                    try {
                        currentMinigame.cleanup();
                    } catch (error) {
                        console.warn('Error cleaning up minigame:', error);
                    }
                    currentMinigame = null;
                }
                
                console.log(`Checkpoint ${currentCheckpoint} deactivated`);
                currentCheckpoint = null;
            }
        }
        
        function initializeMinigame(checkpointNumber) {
            console.log(`Initializing minigame for checkpoint ${checkpointNumber}...`);
            
            const minigames = {
                1: () => new CaptainCompassGame(),
                2: () => new KrakenQuizGame(),
                3: () => new CannonballAccuracyGame(),
                4: () => new TreasureChestLockGame(),
                5: () => new PirateBalanceGame(),
                6: () => new SkeletonDuelGame(),
                7: () => new MapAssemblyGame(),
                8: () => new LostLootGame()
            };
            
            if (minigames[checkpointNumber]) {
                try {
                    currentMinigame = minigames[checkpointNumber]();
                    currentMinigame.initialize();
                    
                    // Show minigame UI
                    document.getElementById('minigame-ui').style.display = 'block';
                    updateMinigameUI();
                    
                    console.log(`Minigame for checkpoint ${checkpointNumber} initialized successfully`);
                } catch (error) {
                    console.error(`Error creating minigame for checkpoint ${checkpointNumber}:`, error);
                    throw error;
                }
            } else {
                console.warn(`No minigame defined for checkpoint ${checkpointNumber}`);
            }
        }
        
        function handleMinigameAction() {
            if (currentMinigame && currentMinigame.handleAction) {
                try {
                    currentMinigame.handleAction();
                    updateMinigameUI();
                } catch (error) {
                    console.error('Error handling minigame action:', error);
                    showError('Error in minigame. Please try again.');
                }
            }
        }
        
        function resetCurrentMinigame() {
            if (currentMinigame && currentMinigame.reset) {
                try {
                    currentMinigame.reset();
                    updateMinigameUI();
                    console.log('Minigame reset successfully');
                } catch (error) {
                    console.error('Error resetting minigame:', error);
                    showError('Error resetting minigame. Please try scanning the marker again.');
                }
            }
        }
        
        function updateMinigameUI() {
            if (currentMinigame) {
                try {
                    const content = document.getElementById('minigame-content');
                    content.innerHTML = currentMinigame.getUIContent();
                    
                    // Update progress bar
                    const progressFill = document.getElementById('progress-fill');
                    progressFill.style.width = `${currentMinigame.getProgress()}%`;
                } catch (error) {
                    console.error('Error updating minigame UI:', error);
                }
            }
        }
        
        async function completeCheckpoint(checkpointNumber, earnedKey = false) {
            try {
                console.log(`Completing checkpoint ${checkpointNumber}, key earned: ${earnedKey}`);
                
                await GameState.completeCheckpoint(checkpointNumber, earnedKey);
                
                const message = `Checkpoint ${checkpointNumber} completed!${earnedKey ? ' Golden key earned!' : ''}`;
                showMessage(message);
                
                // Hide minigame UI after delay
                setTimeout(() => {
                    document.getElementById('minigame-ui').style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('Error completing checkpoint:', error);
                showError('Error saving progress. Please try again.');
            }
        }
        
        function getCheckpointName(number) {
            const names = {
                1: "Captain's Compass",
                2: "Kraken's Quiz", 
                3: "Cannonball Accuracy",
                4: "Treasure Chest Lock",
                5: "Pirate's Balance",
                6: "Skeleton Duel",
                7: "Map Assembly",
                8: "The Lost Loot"
            };
            return names[number] || `Checkpoint ${number}`;
        }
        
        function showMessage(message) {
            console.log('Showing message:', message);
            const instructions = document.getElementById('ar-instructions');
            instructions.innerHTML = `<p style="color: #00ff00;">${message}</p>`;
            
            setTimeout(() => {
                instructions.innerHTML = '<p>Point your camera at an AR marker to begin the minigame</p>';
            }, 3000);
        }
        
        function showError(message) {
            console.error('Showing error:', message);
            const instructions = document.getElementById('ar-instructions');
            instructions.innerHTML = `<p style="color: #ff4444; font-weight: bold;">⚠️ ${message}</p>`;
            
            setTimeout(() => {
                instructions.innerHTML = '<p>Point your camera at an AR marker to begin the minigame</p>';
            }, 5000);
        }
        
        function requestDeviceOrientation() {
            console.log('Checking device orientation permissions...');
            
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                console.log('Device orientation permission required (iOS)');
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            console.log('✅ Device orientation permission granted');
                        } else {
                            console.warn('❌ Device orientation permission denied');
                            showMessage('Device orientation permission denied. Some features may not work properly.');
                        }
                    })
                    .catch(error => {
                        console.error('Device orientation permission error:', error);
                        showMessage('Device orientation setup failed. Please check browser permissions.');
                    });
            } else {
                console.log('Device orientation permission not required');
            }
        }
        
        // Export functions for minigames to use
        window.ARView = {
            completeCheckpoint,
            showMessage,
            showError,
            updateMinigameUI,
            getCurrentCheckpoint: () => currentCheckpoint
        };
        
        // Debug function for testing
        window.ARDebug = {
            getState: () => ({
                arSceneReady,
                arInitialized,
                currentCheckpoint,
                hasMinigame: !!currentMinigame
            }),
            forceActivateCheckpoint: activateCheckpoint,
            testCameraPermission: requestCameraPermission
        };
    </script>
</body>
</html>